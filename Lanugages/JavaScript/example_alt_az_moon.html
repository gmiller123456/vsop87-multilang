<html>
<head></head>
<body>
<h1>This example is still under development</h1>
Simple example to compute the geocentric position of them moon.  Note the reduction algorithm
used is not rigorous, it ignores several factors, like annual abberation, which will result in
a error of many arc seconds.  This example requires vsop87a_full.js.<br><br>
Result:
<pre id="output"></pre>

<pre>
 Date__(UT)__HR:MN     R.A._(ICRF/J2000.0)_DEC R.A.__(a-apparent)__DEC Azi_(a-appr)_Elev L_Ap_Sid_Time   1-way_LT
*****************************************************************************************************************
$$SOE
 2000-Jan-01 12:00 Nm  14 51 12.35 -11 34 39.9 14 51 10.74 -11 34 29.8 146.3255  33.6752 12 58 46.7852   0.022173
 2000-Jan-01 12:00 Nm  222.80147   -11.57774   222.79477   -11.57495   146.3255  33.6752 12.9796625661   0.022173
</pre>

Values from JPL Horizons<br>
-10.90338<br>
222.45893<br>
14h 49m 50.14s<br>
-10d 54' 12.2"<br>


<script src="vsop87a_full.js"></script>
<script>

testMoon();

function display(s){
	const o=document.getElementById("output");
	o.innerHTML=o.innerHTML+s;
}

//Converts a Julan Date to Julian centuries since J2000, which is what VSOP expects as input
function jd2et(jd){
	return (jd - 2451545.0) / 365250.0;

}

//Converts cartesian XYZ coordinates to polar (e.g. Right Accention and Declication)
function toPolar(xyz){
	let t = new Array();
	t[0] = Math.sqrt(xyz[0] * xyz[0] + xyz[1] * xyz[1] + xyz[2] * xyz[2]);
	t[1] = Math.acos(xyz[2] / t[0]);
	t[2] = Math.atan2(xyz[1], xyz[0]);

	return t;
}

//Subtracts two arrays (vectors), a-b
function sub(a, b){
	let t = new Array();
	t[0] = a[0] - b[0];
	t[1] = a[1] - b[1];
	t[2] = a[2] - b[2];
	return t;
}

function displayPolar(b){
	let temp=b[2];
	if(temp<0) temp+=2*Math.PI;
	const ra=(temp * 180 / Math.PI);
	const dec=(90 - b[1] * 180 / Math.PI);
	display("RA:"+ra + "\r\n");
	display("DEC:"+dec + "\r\n");
}

function displayDms(d){
	let t = 90 - d * 180 / Math.PI;
	let deg = Math.trunc(t);
	t = Math.abs(t) - Math.abs(deg);
	t *= 60;
	let min = Math.trunc(t);
	t -= min;
	let sec = t * 60;
	display(deg + "d " + min + "' " + sec + "\"\r\n");
}

function displayHms(h){
	let t = h * 180 / Math.PI+360;
	t /= 15.0;
	let hours = Math.trunc(t);
	t = Math.abs(t) - Math.abs(hours);
	t *= 60;
	let min = Math.trunc(t);
	t -= min;
	let sec = t * 60;
	display(hours + "h " + min + "m " + sec + "s\r\n");
}

function displayCart(b){
	console.log(b[0]);
	console.log(b[1]);
	console.log(b[2]);
}

function rotate(x, angle){
	let t = new Array();
	t[0] = x[0];
	t[1] = x[1] * Math.cos(angle) - x[2] * Math.sin(angle);
	t[2] = x[1] * Math.sin(angle) + x[2] * Math.cos(angle);
	return t;
}

function rotvsop2J2000(x){
	/* From VSOP87.doc
	  X        +1.000000000000  +0.000000440360  -0.000000190919   X
	  Y     =  -0.000000479966  +0.917482137087  -0.397776982902   Y
	  Z FK5     0.000000000000  +0.397776982902  +0.917482137087   Z VSOP87A
	*/
	let t = new Array();
	t[0] = x[0] + x[1] * 0.000000440360 + x[2] * -0.000000190919;
	t[1] = x[0] * -0.000000479966 + x[1] * 0.917482137087 + x[2] * -0.397776982902;
	t[2] = x[1] * 0.397776982902 + x[2] * 0.917482137087;

	return t;
}

//Converts a Julian Date in UTC to TIA
function convertUTCtoTAI(jd){
	//32 leap seconds is hard coded as of Jan 2000, should be updated from the IERS website for other times
	return jd + (32.0 + 32.184) / 24.0 / 60.0 / 60.0;
}

//Step 2: Convert Geodedic Lat Lon to geocentric XYZ position vector
function convertGeodedicLatLonToITRFXYZ(lat,lon,height){
	const a=6378136.6;
	const f=1/298.25642;

	const C=Math.sqrt(((Math.cos(lat)*Math.cos(lat)) + (1.0-f)*(1.0-f) * (Math.sin(lat)*Math.sin(lat))));

	const S=(1-f)*(1-f)*C;
	
	const h=height;

	let r=new Array();
	r[0]=(a*C+h) * Math.cos(lat) * Math.cos(lon);
	r[1]=(a*C+h) * Math.cos(lat) * Math.sin(lon);
	r[2]=(a*S+h) * Math.sin(lat);
	
	return r;
}

function getGMST(ut1){
	const D=ut1 - 2451545.0;
	const T = D/36525.0;
	
	let GMST = (24110.54841 + 8640184.812866*T + 0.093104*T*T - 6.2E-6*T*T*T)/60.0/60.0 % 24.0;
	
	return GMST;
	
}
//Step 3: Convert position vector to celestial "of date" system.
//g(t)=R3(-GAST) r
//(Remember to use UT1 for GAST, not ET)
function convertITRFToGCRS(r,ut1){
	
	//GMST=(12.9796625661-274.236400)%360.0
	//apply rotation matrix R3(-GMST);
	
	let GMST=getGMST(ut1);
	GMST=GMST*15.0*Math.PI/180.0;
	let t=new Array();
	t[0]=r[0]*Math.cos(GMST) + r[1]*Math.sin(GMST);
	t[1]=r[0]*(-Math.sin(GMST)) + r[1]*Math.cos(GMST);
	t[2]=r[2];
	
	return t;
	
	
	/*R3
	# cos(a) sin(a) 0
	#-sin(a) cos(a) 0
	#   0      0    1
	*/
}

//Step 4: Convert from meters to AU
//Multiply g(t) by 1.49597870691E+11
function convertFromMetersToAU(r){
	let t=new Array();
	
	t[0]=r[0]/1.49597870691E+11;
	t[1]=r[1]/1.49597870691E+11;
	t[2]=r[2]/1.49597870691E+11;
	
	return t;
}

function getObserverGeocentric(jd,lat,lon){
	let r=convertGeodedicLatLonToITRFXYZ(lat, lon,0);
	console.log(r);
	r=convertITRFToGCRS(r,jd);
	console.log(r);
	r=convertFromMetersToAU(r);
	
	return r;
}



function testMoon(){
	const jd=2451545.000000; //Jan 1 2000, 12:00p UTC
	const jdTAI = convertUTCtoTAI(jd);
	let t = jd2et(jdTAI);
	
	//Get current position of Earth
	const earth = vsop87a_full.getEarth(t);
	
	//Get current position of Moon
	let moon = vsop87a_full.getMoon(vsop87a_full.getEarth(t), vsop87a_full.getEmb(t));
	moon = sub(moon, earth);

	//Calculate light time to moon, then recalculate Moon position adjusted for light time
	let distance = Math.sqrt(moon[0] * moon[0] + moon[1] * moon[1] + moon[2] * moon[2]);
	distance*=1.496e+11 //Convert from AU to meters
	display("Distance="+(distance)+" meters\r\n");
	const lightTime=distance/299792458.0;
	display("Light Time="+lightTime+" seconds\r\n");

	//Convert light time to Julian Centuries, and subtract it from the original value of t
	t-=lightTime / 24.0 / 60.0 / 60.0 / 365250.0;  
	moon = vsop87a_full.getMoon(vsop87a_full.getEarth(t), vsop87a_full.getEmb(t));
	
	//Convert to Geocrntric position
	moon = sub(moon, earth);

	
	//Convert to topocentric
	const lon=274.236400*Math.PI/180;
	const lat=38.2464000*Math.PI/180;
	observerXYZ=getObserverGeocentric(jd,lat,lon);
	moon = sub(moon,observerXYZ);

	//Rotate ecliptic coordinates to J2000 coordinates
	moon = rotvsop2J2000(moon);


	moon = toPolar(moon);
	//moon now holds the RA and DEC, display them in decimal and verbose form
	
	
	

	displayPolar(moon);

	displayHms(moon[2]);
	displayDms(moon[1]);

}

</script></body></html>