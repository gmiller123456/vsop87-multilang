<html>
<head></head>
<body>
<h1>This example is still under development</h1>
Simple example to compute the geocentric position of the moon.  Note the reduction algorithm
used is not rigorous, it ignores several factors, like annual abberation, which will result in
a error of many arc seconds.  This example requires vsop87a_full.js.<br><br>
Result:
<pre id="output"></pre>


Values from JPL Horizons<br>
<pre>
 Date__(UT)__HR:MN     R.A._(ICRF/J2000.0)_DEC R.A.__(a-apparent)__DEC Azi_(a-appr)_Elev L_Ap_Sid_Time   1-way_LT
*****************************************************************************************************************
$$SOE
 2000-Jan-01 12:00 Nm  14 51 12.35 -11 34 39.9 14 51 10.74 -11 34 29.8 146.3255  33.6752 12 58 46.7852   0.022173
 2000-Jan-01 12:00 Nm  222.80147   -11.57774   222.79477   -11.57495   146.3255  33.6752 12.9796625661   0.022173
</pre>



<script src="vsop87a_full.js"></script>
<script>

testMoon();

function display(s){
	const o=document.getElementById("output");
	o.innerHTML=o.innerHTML+s;
}

//Converts a Julan Date to Julian centuries since J2000, which is what VSOP expects as input
function jd2et(jd){
	return (jd - 2451545.0) / 365250.0;

}

//Converts cartesian XYZ coordinates to polar (e.g. J2000 xyz to Right Accention and Declication)
function toPolar(xyz){
	let t = new Array();
	t[0] = Math.sqrt(xyz[0] * xyz[0] + xyz[1] * xyz[1] + xyz[2] * xyz[2]);
	t[1] = Math.acos(xyz[2] / t[0]);
	t[2] = Math.atan2(xyz[1], xyz[0]);

	return t;
}

//Subtracts two arrays (vectors), a-b
function sub(a, b){
	let t = new Array();
	t[0] = a[0] - b[0];
	t[1] = a[1] - b[1];
	t[2] = a[2] - b[2];
	return t;
}

function displayPolar(b){
	let temp=b[2];
	if(temp<0) temp+=2*Math.PI;
	const ra=(temp * 180 / Math.PI);
	const dec=(90 - b[1] * 180 / Math.PI);
	display("RA:"+ra + "\r\n");
	display("DEC:"+dec + "\r\n");
}

function displayDms(d){
	let t = 90 - d * 180 / Math.PI;
	let deg = Math.trunc(t);
	t = Math.abs(t) - Math.abs(deg);
	t *= 60;
	let min = Math.trunc(t);
	t -= min;
	let sec = t * 60;
	display(deg + "d " + min + "' " + sec + "\"\r\n");
}

function displayHms(h){
	let t = h * 180 / Math.PI;
	if(t<0)t+=360;
	t /= 15.0;
	let hours = Math.trunc(t);
	t = Math.abs(t) - Math.abs(hours);
	t *= 60;
	let min = Math.trunc(t);
	t -= min;
	let sec = t * 60;
	display(hours + "h " + min + "m " + sec + "s\r\n");
}

function displayCart(b){
	console.log(b[0]);
	console.log(b[1]);
	console.log(b[2]);
}

function rotate(x, angle){
	let t = new Array();
	t[0] = x[0];
	t[1] = x[1] * Math.cos(angle) - x[2] * Math.sin(angle);
	t[2] = x[1] * Math.sin(angle) + x[2] * Math.cos(angle);
	return t;
}

function rotvsop2J2000(x){
	/* From VSOP87.doc
	  X        +1.000000000000  +0.000000440360  -0.000000190919   X
	  Y     =  -0.000000479966  +0.917482137087  -0.397776982902   Y
	  Z FK5     0.000000000000  +0.397776982902  +0.917482137087   Z VSOP87A
	*/
	let t = new Array();
	t[0] = x[0] + x[1] * 0.000000440360 + x[2] * -0.000000190919;
	t[1] = x[0] * -0.000000479966 + x[1] * 0.917482137087 + x[2] * -0.397776982902;
	t[2] = x[1] * 0.397776982902 + x[2] * 0.917482137087;

	return t;
}

//Converts a Julian Date in UTC to TIA
function convertUTCtoTT(jd){
	//32 leap seconds is hard coded as of Jan 2000, should be updated from the IERS website for other times
	
	//TAI = UTC + leap seconds (e.g. 32)
	//TT=TAI + 32.184

	return jd + (32.0 + 32.184) / 24.0 / 60.0 / 60.0;
}

//Step 2: Convert Geodedic Lat Lon to geocentric XYZ position vector
function convertGeodedicLatLonToITRFXYZ(lat,lon,height){
	const a=6378136.6;
	const f=1/298.25642;

	const C=Math.sqrt(((Math.cos(lat)*Math.cos(lat)) + (1.0-f)*(1.0-f) * (Math.sin(lat)*Math.sin(lat))));

	const S=(1-f)*(1-f)*C;
	
	const h=height;

	let r=new Array();
	r[0]=(a*C+h) * Math.cos(lat) * Math.cos(lon);
	r[1]=(a*C+h) * Math.cos(lat) * Math.sin(lon);
	r[2]=(a*S+h) * Math.sin(lat);
	
	return r;
}

function getGMST(ut1){
	const midnight=Math.trunc(ut1)+0.5;
	const frac=(ut1-midnight)*24.0;

	const D=midnight - 2451545.0;
	const T = D/36525.0;

	let GMST = ((24110.54841 + 8640184.812866*T + 0.093104*T*T - 6.2E-6*T*T*T)/60.0/60.0 + frac) % 24.0;
	return GMST;
	
}
//Step 3: Convert position vector to celestial "of date" system.
//g(t)=R3(-GAST) r
//(Remember to use UT1 for GAST, not ET)
function convertITRFToGCRS(r,ut1){

	let GMST=getGMST(ut1);
	GMST=-GMST*15.0*Math.PI/180.0;
	let t=new Array();
	t[0]=r[0]*Math.cos(GMST) + r[1]*(Math.sin(GMST));
	t[1]=r[0]*(-Math.sin(GMST)) + r[1]*Math.cos(GMST);
	t[2]=r[2];

	return t;
}

//Step 4: Convert from meters to AU
//Multiply g(t) by 1.49597870691E+11
function convertFromMetersToAU(r){
	let t=new Array();
	
	t[0]=r[0]/1.49597870691E+11;
	t[1]=r[1]/1.49597870691E+11;
	t[2]=r[2]/1.49597870691E+11;
	
	return t;
}

function getObserverGeocentric(jd,lat,lon){
	let r=convertGeodedicLatLonToITRFXYZ(lat, lon,0);
	r=convertITRFToGCRS(r,jd);
	r=convertFromMetersToAU(r);
	
	return r;
}

function convertRaDecToAltAz(jd,lat,lon,ra,dec){
	/* From Meeus Astronomical Algorithms P93
	H=GMST - lon - ra
	tan(A)=sin(H)/(cos(H)*sin(lat)-tan(dec)*cos(lat));
	sin(h)=sin(lat)*sin(dec)+cos(lat)*cos(dec)*cos(H);
	*/
	const GMST=getGMST(jd)*15.0*Math.PI/180.0;
	const H=GMST + lon - ra;
	console.log((GMST + lon)*180.0/Math.PI*24.0 % 24.0 + 24.0)
	const A=Math.atan2(Math.sin(H),(Math.cos(H)*Math.sin(lat)-Math.tan(dec)*Math.cos(lat)));
	const h=Math.asin(Math.sin(lat)*Math.sin(dec)+Math.cos(lat)*Math.cos(dec)*Math.cos(H));
	
	let t=new Array();
	t[0]=A;
	t[1]=h;
	
	return t;
}


function testMoon(){
	const jd=2451545.000000;

	const jdTAI = convertUTCtoTT(jd);
	let t = jd2et(jdTAI);
	
	//Get current position of Earth
	const earth = vsop87a_full.getEarth(t);
	
	//Get current position of Moon
	let moon = vsop87a_full.getMoon(vsop87a_full.getEarth(t), vsop87a_full.getEmb(t));
	moon = sub(moon, earth);

	//Calculate light time to moon, then recalculate Moon position adjusted for light time
	let distance = Math.sqrt(moon[0] * moon[0] + moon[1] * moon[1] + moon[2] * moon[2]);
	distance*=1.496e+11 //Convert from AU to meters
	display("Distance="+(distance)+" meters\r\n");
	const lightTime=distance/299792458.0;
	display("Light Time="+lightTime+" seconds\r\n");

	//Convert light time to Julian Centuries, and subtract it from the original value of t
	t-=lightTime / 24.0 / 60.0 / 60.0 / 365250.0;  
	moon = vsop87a_full.getMoon(vsop87a_full.getEarth(t), vsop87a_full.getEmb(t));
	
	//Convert to Geocrntric position
	moon = sub(moon, earth);
	
	//Rotate ecliptic coordinates to J2000 coordinates
	moon = rotvsop2J2000(moon);

	//Convert to topocentric
	const lon=274.236400*Math.PI/180;
	const lat=38.2464000*Math.PI/180;
	observerXYZ=getObserverGeocentric(jdTAI,lat,lon);
	moon = sub(moon,observerXYZ);

	//Convert to RA DEC
	moonRaDec = toPolar(moon);
	
	displayPolar(moonRaDec);

	displayHms(moonRaDec[2]);
	displayDms(moonRaDec[1]);
	
	moonAltAz=convertRaDecToAltAz(jdTAI,lat*Math.PI/180.0,lon*Math.PI/180.0,moonRaDec[2],moonRaDec[1]);
	displayDms(moonAltAz[0]);
	displayDms(moonAltAz[1]);

}

</script></body></html>